	IDEAL				;"идеальный" режим ассемблирования
	P486				;использование команд ЦПУ I80486
AttrPl	EQU	01111010b		;атрибуты: полос окаймления
AttrBG	EQU	00111111b		;фона
;==============================================================================
MACRO	TestCPU OpCode		;макрокоманда проверки наличия команды ЦПУ
	push	ds			;сохранить адрес сегмента данных
	mov	ax,3506h		;функция получения адреса процедуры
	int	21h			;обработки прерывания int 06h
	mov	[Word OldInt],bx	;сохранение этого адреса
	mov	[Word OldInt+2],es
	mov	ax,2506h		;функция установки нового обработчика
	mov	dx,seg NewInt6		;сегмент обработчика
	mov	ds,dx
	mov	dx,offset NewInt6	;смещение обработчика
	int	21h			;установка
	mov	bp,sp			;адрес вершины стека в модификатор
	mov	ds,[bp]			;восстановление сегмента данных
	lea	bx,[CPU_Type]		;адрес переменной в модификатор
	mov	[Byte bx],11h		;запись в переменную флага ошибки
	DB	OpCode			;место для проверяемого кода операции
	lds	dx,[OldInt]		;адрес старого обработчика
	mov	ax,2506h		;функция установки обработчика
	int	21h			;установка
	pop	ds			;восстановление сегмента данных
ENDM
;==============================================================================
;макрокоманда вывода строки через BIOS-прерывание int 10h
MACRO	PrnStr	Txt,Attrib,Len,Str,Col,Func
	push	ax bx cx dx bp es	;сохранение рабочих регистров
	mov	ax,(13h shl 8)+Func	;вариант вывода строки
	mov	bx,Attrib		;атрибут символов
	mov	cx,Len			;длина строки
	mov	dx,(Str shl 8)+Col	;координаты начала строки
	push	ds			;адрес сегмента данных
	pop	es			;в регистр es
	lea	bp,[Txt]		;адрес строки
	int	10h			;выполнение функции вывода
	pop	es bp dx cx bx ax	;восстановление рабочих регистров
ENDM
;==============================================================================                                                                                            ;
MACRO	Curs	x,y			;макрокоманда установки курсора
	mov	dx,(y shl 8)+x		;координаты курсора
	call	MoveAt			;вызов процедуры
ENDM
;==============================================================================
MACRO	Print	StrName			;макрокоманда вывода строки
	lea	dx,[StrName]		;адрес строки
	call	OutStr			;вызов процедуры
ENDM
;==============================================================================
SEGMENT		_data para 'data'	;сегмент данных
HiLn		DB	' System Checking 2000 '
LoLn		DB	' Written by Ross '
Mmes		DB	'Machine Type         : IBM ?? or compatible$'
Pmes		DB	'Central Processor    : $'
Cmes		DB	'Math Co-processor    : $'
Vmes		DB	'Video Adapter        : $'
BM		DB	'Base Memory Size     : $'
EM		DB	'Extended Memory Size : $'
SPmes		DB	'Serial Ports         : ? ->  '
		DB	'COM1    COM2    COM3    COM4$'
PPmes		DB	'Parallel Ports       : ? ->  '
		DB	'LPT1    LPT2    LPT3    LPT4$'
Jmes		DB	'Game Port            : $'
FDm		DB	'Floppy Disk Drives   : $'
FDa		DB	'A: $'
FDb		DB	'B: $'
HDm1		DB	'Hard Disk Drives     : Master : $'
HDm2		DB	'Slave  : $'
Dmes		DB	'DOS Vesion           : ?.??$'
f360		DB	'360 Kb (5.25")$'
f12		DB	'1.2 Mb (5.25")$'
f720		DB	'720 Kb (3.5")$'
f144		DB	'1.44 Mb (3.5")$'
f288		DB	'2.88 Mb (3.5")$'
NotP		DB	'None    $'
Pres		DB	'Present$'
kb		DB	' Kbyte$'
PC_Type		DB	?		;переменная для типа компьютера
CPU_Type	DB	0		;переменная для типа ЦПУ
CPU_Table	DW	Unk,CPU86,CPU186,CPU286,CPU386	;таблица адресов
		DW	CPU486,I4,I5,IPro,Cx4,Cx5,Am4,Am5,P6
Unk		DB	'Unknown $'		;тип 0
CPU86		DB	'8086 (or 8088)$'	;1
CPU186		DB	'80186$'		;2
CPU286		DB	'80286$'		;3
CPU386		DB	'80386$'		;4
CPU486		DB	'80486$'		;5
I4		DB	'Intel 80486$'		;6
I5		DB	'Intel Pentium$'	;7
IPro		DB	'Intel Pentium Pro$'	;8
Cx4		DB	'Cyrix 486$'		;9
Cx5		DB	'Cyrix M1 (P5 Family)$'	;0Ah
Am4		DB	'AMD 5x86 (486 Family)$';0Bh
Am5		DB	'AMD K5 (P5 Family)$'	;0Ch
P6		DB	'Pentium II or P6 Family$';0Dh
MMX		DB	' + MMX$'
SVGA		DB	'SVGA [VESA Ver. 0.0]$'
MDA		DB	'MDA$'
C40		DB	'CGA 40 x 25$'
C80		DB	'CGA 80 x 25$'
EGA		DB	'EGA$'
VGA		DB	' or VGA$'
OldInt		DD	?	;место для сохранения адреса обработчика прерывания
HexBuf		DB	4 dup (' ')	;буфер для шестнадцатиричного числа
		DB	'h   $'
DecBuf		DB	5 dup (0)	;буфер для десятичного числа
Buf		DB	512 dup (?)	;вспомогательный буфер для обмена данными
ENDS		_data
;==============================================================================
SEGMENT     _text PARA 'code'           ;кодовый сегмент
            ASSUME  cs:_text,ds:_data   ;привязка сегментных регистров
Start:      mov     ax,_data            ;загрузка адреса сегмента данных
            mov     ds,ax
            call    Image               ;оформление экрана
            call    HideCur             ;выключение курсора
            call    PC_Def              ;определение типа машины
            call    CPU_Def             ;определение типа ЦПУ
            call    MPU_Def             ;определение наличия мат. сопроцессора
            call    Video_Def           ;определение типа видеоадаптера
            call    Ports_Def           ;определение портов ввода-вывода
            call    DD_Def              ;определение типа дисковых устройств
            call    Mem_Def             ;определение количества памяти
            call    DOS_Def             ;определение версии DOS
            call    WaitKey             ;ожидание нажатия клавиши
            mov     ax,0003h            ;функция установки видеорежима
            int     10h                 ;16 цв. 80х25 символов
            mov     ax,4C00h            ;функция DOS "окончание программы с
            int     21h                 ;передачей кода завершения"
;==============================================================================
PROC        MoveAt                      ;процедура установки курсора
            push    ax bx               ;сохранение рабочих регистров
            xor     bx,bx               ;видеостраница #0
            mov     ah,02               ;функция установки курсора
            int     10h                 ;по заданным координатам
            pop     bx ax               ;восстановление регистров
            ret                         ;возврат
ENDP        MoveAt
;==============================================================================
PROC        OutStr                      ;процедура вывода строки
            push    ax                  ;сохранение регистра
            mov     ah,09h              ;вывод строки символов на консоль
            int     21h                 ;вызов функции
            pop     ax                  ;восстановление регистра
            ret                         ;возврат
ENDP        OutStr
;==============================================================================
PROC        WaitKey                     ;процедура ожидания нажатия клавиши
            mov    ah,0Ch               ;очистка буфера клавиатуры
            mov    al,08h               ;функция ввода символа без эха
            int    21h                  ;вызов функции
            ret                         ;возврат
ENDP        WaitKey
;==============================================================================
PROC        HideCur                     ;процедура выключения курсора
            push     ax cx              ;сохранение регистров
            mov      ah,01h             ;установка размера и формы курсора
            mov      cx,2000h           ;20 - подавить курсор
            int      10h                ;вызов функций
            pop      cx ax              ;восстановить регистры
            ret                         ;возврат
ENDP        HideCur
;==============================================================================
PROC        Image                       ;процедура оформления экрана
            push    ax bx cx dx         ;сохранение рабочих регистров
            mov     ax,0003h            ;функция установки видеорежима
            int     10h                 ;16 цв. 80х25 символов
            mov     ax,0600h            ;функция очистки экрана (ah=6,al=0)
            mov     bh,AttrBG           ;атрибут
            mov     cx,0000h            ;координаты "окна"
            mov     dx,184Fh
            int     10h                 ;очистка всего экрана
            mov     ax,0AC9h            ;функция 0A вывода символа "уголок"
            xor     bh,bh               ;страница 0
            mov     cx,1                ;количество = 1
            int     10h                 ;выполнение функции BIOS
            mov     dx,1                ;перемещение курсора
            call    MoveAt
            mov     al,0CDh             ;символ рамки
            mov     cx,78               ;количество = 78
            int     10h                 ;вывод
            mov     dx,79               ;перемещение курсора
            call    MoveAt
            mov     al,0BBh             ;"уголок"
            mov     cx,1                ;количество = 1
            int     10h                 ;вывод
            mov     dx,0100h            ;перемещение курсора
            call    MoveAt
            mov     cx,23               ;23 строки вертикальных
            mov     ax,0EBAh            ;элементов
repstr:     int     10h                 ;вывод
            mov     dl,79               ;перемещение курсора
            call    MoveAt
            inc     dh                  ;следующая строка
            int     10h                 ;вывод
            loop    repstr              ;повтор
            mov     ax,0AC8h            ;"уголок"
            mov     cx,1                ;количество = 1
            int     10h                 ;вывод
            mov     dx,(24 shl 8)+1     ;перемещение курсора
            call    MoveAt
            mov     al,0CDh             ;символ рамки
            mov     cx,78               ;количество = 78
            int     10h                 ;вывод
            mov     dl,79               ;перемещение курсора
            call    MoveAt
            mov     al,0BCh             ;"уголок"
            mov     cx,1                ;количество = 1
            int     10h                 ;вывод
            ;печать верхней и нижней строк оформления
            PrnStr  HiLn,AttrPl,LoLn-HiLn,0,40-((LoLn-HiLn)/2),0
            PrnStr  LoLn,AttrPl,Mmes-LoLn,24,40-((Mmes-LoLn)/2),0
            pop     dx cx bx ax         ;восстановить регистры
            ret                         ;возврат
ENDP        Image
;==============================================================================
PROC        PC_Def                      ;процедура определения типа ЭВМ
            lea     bx,[Mmes]           ;адрес сообщения о типе машины
            mov     ax,0F000h           ;указывает ES на ПЗУ
            mov     es,ax
            mov     al,[es:0FFFEh]      ;байт с кодом типа ЭВМ
            mov     [PC_Type],al        ;сохранение кода в переменной
            cmp     al,0FCh             ;это AT?
            jne     noAT                ;если нет - переход
            mov     [Byte bx+27],'A'    ;вставка в сообщение типа
            mov     [Byte bx+28],'T'
            jmp     EndPD               ;конец
noAT:       cmp     al,0FEh             ;это XT?
            jne     noXT                ;если нет - переход
            mov     [Byte bx+27],'X'    ;вставка в сообщение типа
            mov     [Byte bx+28],'T'
            jmp     EndPD               ;конец
noXT:       mov     [Byte bx+27],'P'    ;вставка в сообщение типа
            mov     [Byte bx+28],'C'
EndPD:      Curs    13,2                ;установка курсора
            Print   Mmes                ;вывод типа на экран
            ret                         ;возврат
ENDP        PC_Def
;==============================================================================
PROC        CPU_Def                     ;процедура определения ЦПУ
            Curs    13,4                ;установка курсора
            Print   Pmes                ;вывод сообщения о ЦПУ
            Curs    36,4                ;координаты курсора
            push    bx es               ;сохранение рабочих регистров
            push    sp                  ;сохранение указателя стека
            pop     ax                  ;считывание его в переменную
            cmp     ax,sp               ;сравнивание значений
            je      no88                ;если равны, то ЦПУ - не 8086 (8088)
            mov     [CPU_Type],1        ;иначе - код процессора в переменную
            jmp     EndCD               ;конец
no88:       TestCPU <0Fh,0C1h,0D2h>     ;проверка наличия команды xadd dx,dx
            cmp     [Byte bx],11h       ;проверка флага наличия
            jne     no486               ;если флаг неравен 11h, ЦПУ ниже 486
            pushfd                      ;регистр флагов - в стек
            mov     bp,sp               ;указатель на стек - в модификатор
            or      [Byte bp+2],100000b ;установка 21 бита - поддержка cpuid
            popfd                       ;загрузка регистра флагов
            pushfd                      ;регистр флагов - в стек
            mov     bp,sp               ;указатель на стек - в модификатор
            test    [Byte bp+2],100000b ;проверка 21 бита
            jnz     id                  ;если бит 21=1, то использование cpuid
            popfd                       ;возвратить eflags обратно
id486:      mov     [CPU_Type],5        ;иначе - это 80486
            jmp     EndCD               ;конец
no486:      TestCPU <0Fh,20h,0C2h>      ;проверка наличия команды mov edx,cr0
            cmp     [Byte bx],11h       ;проверка флага наличия
            jne     no386               ;если флаг неравен 11h, ЦПУ ниже 386
            mov     [CPU_Type],4        ;иначе - код процессора в переменную
            jmp     EndCD               ;конец
no386:      TestCPU <0Fh,01h,0E2h>      ;проверка наличия команды smsw dx
            cmp     [Byte bx],11h       ;проверка флага наличия
            jne     no286               ;если флаг неравен 11h, ЦПУ ниже 286
            mov     [CPU_Type],3        ;иначе - код процессора в переменную
            jmp     EndCD               ;конец
no286:      TestCPU <0C1h,0E2h,05h>     ;проверка наличия команды shl dx,5
            cmp     [Byte bx],11h       ;проверка флага наличия
            jne     EndCD               ;если флаг неравен 11h, ЦПУ неизвестен
            mov     [CPU_Type],2        ;иначе - код процессора в переменную
            jmp     EndCD               ;конец
id:         popfd                       ;возвратить eflags обратно
            xor     eax,eax             ;обнуление регистра
            DB      0Fh,0A2h            ;команда cpuid
            cmp     eax,1               ;в eax - максимальный номер функции,
                                        ;поддерживаемый cpuid
            ja      p6fam               ;больше 1 - значит семейство P6, иначе
            cmp     ebx,'uneG'          ;проверяем идентификационные коды
            jne     notint              ;переход, если не Intel
            call    Ident               ;идентификация ЦПУ
            cmp     ax,4                ;486 ?
            jne     noti4               ;нет - переход
            mov     [CPU_Type],6        ;тип - Intel 486
            jmp     EndCD               ;конец
noti4:      cmp     ax,5                ;семейство P5 ?
            jne     noti5               ;нет - переход
            mov     [CPU_Type],7        ;тип - Pentium
            jmp     EndCD               ;конец
noti5:      mov     [CPU_Type],8        ;тип - Pentium Pro
            jmp     EndCD               ;конец
notint:     cmp     ebx,'iryC'          ;это Cyrix ?
            jne     notcyr              ;нет - переход
            call    Ident               ;идентификация ЦПУ
            cmp     ax,4                ;486 ?
            jne     notc4               ;нет - переход
            mov     [CPU_Type],9        ;тип - Cyrix 486
            jmp     EndCD               ;конец
notc4:      mov     [CPU_Type],0Ah      ;Cyrix M1 586
            jmp     EndCD               ;конец
notcyr:     cmp     ebx,'htuA'          ;это AMD ?
            jne     EndCD               ;нет - конец
            call    Ident               ;идентификация ЦПУ
            cmp     ax,4                ;486 ?
            jne     nota4               ;нет - переход
            mov     [CPU_Type],0Bh      ;тип - AMD 5x86
            jmp     EndCD               ;конец
nota4:      mov     [CPU_Type],0Ch      ;тип - AMD 586
            jmp     EndCD               ;конец
p6fam:      mov     [CPU_Type],0Dh      ;тип - P6 Family
EndCD:      xor     bx,bx               ;очистка регистра
            mov     bl,[CPU_Type]       ;считывание кода ЦПУ
            shl     bx,1                ;умножение кода на 2
            mov     dx,[CPU_Table+bx]   ;выборка адреса из таблицы адресов
            call    OutStr              ;вывод типа ЦПУ
            cmp     [CPU_Type],7        ;ЦПУ Pentium и выше ?
            jb      exitCD              ;нет - выход
            call    Ident               ;да - идентификация
            test    edx,800000h         ;проверка поддержки MMX технологии
            jz      exitCD              ;нет поддержки - выход
            Print   MMX                 ;вывод сообщения об MMX
exitCD:     pop     es bx               ;восстановление рабочих регистров
            ret                         ;возврат
ENDP        CPU_Def
;==============================================================================
PROC        Ident                       ;процедура идентификации процессора
            mov     eax,1               ;функция 1
            DB      0Fh,0A2h            ;команда cpuid
            shr     ax,8                ;сдвиг до номера семейства
            and     ax,15               ;выделение 4-х битов семейства
            ret                         ;возврат
ENDP        Ident
;==============================================================================
PROC        MPU_Def   ;процедура проверки наличия математического сопроцессора
            push    ax es               ;сохранение рабочих регистров
            Curs    13,5                ;установка курсора
            Print   Cmes                ;вывод сообщения о FPU
            Curs    36,5                ;установка курсора
            cmp     [CPU_Type],7        ;это Pentium и выше ?
            jb      lodef               ;нет - определение по данным CMOS
            call    Ident               ;иначе идентификация командой cpuid
            test    edx,1               ;сопроцессор есть ?
            jz      noMPU               ;нет - сообщить
            jmp     exist               ;иначе - есть
lodef:      cmp     [PC_Type],0FFh      ;это PC ?
            je      noMPU               ;тогда у него нет FPU
            mov     ax,40h              ;иначе, в es - адрес области
            mov     es,ax               ;переменных BIOS
            mov     al,[es:10h]         ;младший байт конфигурации
            test    al,2                ;проверить бит сопроцессора
            jz      noMPU               ;0 - значит нет FPU
exist:      lea     dx,[Pres]           ;1 - есть, вывести сообщение
            jmp     EndMPU              ;конец
noMPU:      lea     dx,[NotP]           ;сообщение "отсутствует"
EndMPU:     call    OutStr              ;вывод строки
            pop     es ax               ;восстановление рабочих регистров
            ret
ENDP        MPU_Def
;==============================================================================
PROC        NewInt6                     ;обработчик 6-го прерывания
            pusha                       ;сохранение всех рабочих регистров
            mov    [Byte ds:bx],10h     ;флаг неверной команды
            mov    bp,sp                ;адрес вершины стека
            add    [Word bp+16],3       ;адрес возврата - после адреса
                                        ;неверной команды длиной 3 байта
            popa                        ;восстановление всех рабочих регистров
            iret                        ;возврат из прерывания
ENDP        NewInt6
;==============================================================================
PROC        Video_Def                   ;проц. определения типа видеоадаптера
            Curs    13,7                ;установка курсора
            Print   Vmes                ;сообщение о видеоадаптере
            Curs    36,7                ;установка курсора
            cmp     [PC_Type],0FCh      ;это AT ?
            je      at                  ;да - проверить SVGA
            mov     ax,40h              ;указываем ES на область данных BIOS
            mov     es,ax
            mov     al,[es:87h]         ;проверяем наличие EGA
            or      al,al               ;в al 0 ?
            je      eganoact            ;если 0040:0087 = 0, то EGA нет
            test    al,8                ;EGA есть, проверяем бит 3
            jnz     eganoact            ;если бит 3=1, то EGA неактивен
            lea     dx,[EGA]            ;адрес строки EGA
            jmp     quit                ;конец
eganoact:   mov     al,[es:10h]         ;проверяем байт статуса дисплея
            and     al,48               ;выделяем биты 4 и 5
            cmp     al,48               ;это монохромная карта?
            je      mono                ;переход, если да
            cmp     al,32               ;это CGA 80x25 ?
            je      col80               ;переход, если да
            cmp     al,16               ;это CGA 40x25 ?
            je      col40               ;переход, если да
            lea     dx,[Unk]            ;иначе - неизвестный адаптер
            jmp     quit                ;конец
at:         push    ds                  ;сегмент данных в es
            pop     es
            lea     di,[Buf]            ;адрес буфера для информации VESA
            mov     ax,4F00h            ;функция определения SVGA
            int     10h                 ;BIOS-прерывание
            cmp     al,4Fh              ;проверка - поддерживается эта функция
            jne     notsup              ;нет - переход
            mov     ax,[di+4]           ;считывание номера версии VESA
            add     ax,3030h            ;преобразование номера в ASCII
            mov     [SVGA+16],ah        ;вставка номера в выводимую строку
            mov     [SVGA+18],al
            lea     dx,[SVGA]           ;адрес строки-сообщения
            jmp     quit                ;конец
notsup:     mov     al,14h              ;14h - ячейка CMOS - конфигурация
            out     70h,al              ;выбор ячейки через порт
            jmp     $+2                 ;задержка для срабатывания схем CMOS
            in      al,71h              ;ввод значения конфигурации
            and     al,48               ;выделение бит видеоадаптера
            or      al,al               ;проверка на 0 - EGA или VGA
            jne     notega              ;не 0 - переход
            Print   EGA                 ;иначе вывод строки EGA
            lea     dx,[VGA]            ;и подготовка вывода VGA
            jmp     quit                ;на выход
notega:     cmp     al,16               ;это CGA 40x25 ?
            jne     not40               ;нет - переход
col40:      lea     dx,[C40]            ;адрес строки CGA
            jmp     quit                ;на выход
not40:      cmp     al,32               ;это CGA 80x25 ?
            jne     mono                ;нет - значит MDA
col80:      lea     dx,[C80]            ;адрес строки
            jmp     quit                ;выход
mono:       lea     dx,[MDA]            ;строка MDA
quit:       call    OutStr              ;вывод строки
            ret                         ;и выход
ENDP        Video_Def
;==============================================================================
PROC        Mem_Def                 ;процедура определения объема памяти
            Curs    13,9            ;установка кусора
            Print   BM              ;адрес строки для основной памяти
            cmp     [PC_Type],0FCh  ;это AT ?
            je      atmem           ;да - переход
            mov     ax,40h          ;иначе установка на область переменных
            mov     es,ax           ;BIOS
            mov     ax,[es:13h]     ;чтение ячейки с размером базовой памяти
            call    bin2dec         ;преобразование числа в ASCII
            Print   DecBuf          ;печать числа
            jmp     endmem          ;конец
atmem:      mov     di,70h          ;адрес порта КМОП-ОЗУ для выбора регистров
            mov     si,71h          ;адрес порта для чтения-записи данных
            mov     dx,di           ;выбор ячейки с адресом
            mov     al,16h          ;16h - базовая память (старший байт)
            out     dx,al           ;вывод адреса
            jmp     $+2             ;задержка
            mov     dx,si           ;из порта данных
            in      al,dx           ;чтение значения
            mov     ah,al           ;перенос его в старший регистр
            mov     dx,di           ;то же для 15h ячейки (младший байт)
            mov     al,15h
            out     dx,al
            jmp     $+2
            mov     dx,si
            in      al,dx
            call    bin2dec         ;преобразование в ASCII
            Print   DecBuf          ;загрузка адреса и вывод числа
            Print   kb              ;вывод размерности "Kb"
            Curs    13,10           ;координаты курсора
            Print   EM              ;адрес строки для расширенной памяти
            mov     dx,di           ;выбор ячейки с адресом
            mov     al,18h          ;18h - расширенная память (ст. байт)
            out     dx,al           ;вывод адреса
            jmp     $+2             ;задержка
            mov     dx,si           ;из порта данных
            in      al,dx           ;чтение значения
            mov     ah,al           ;перенос его в старший регистр
            mov     dx,di           ;то же для 17h ячейки (мл. байт)
            mov     al,17h
            out     dx,al
            jmp     $+2
            mov     dx,si
            in      al,dx
            call    bin2dec         ;преобразование числа в ASCII
            Print   DecBuf          ;адрес числа в буфере
endmem:     Print   kb              ;вывод размерности "Kb"
            ret
ENDP        Mem_Def
;==============================================================================
PROC        Ports_Def ;процедура определения количества, типа и адресов портов
            Curs    13,16           ;установка курсора
            Print   Jmes            ;вывод сообщения об игровом адаптере
            mov     ax,40h          ;указывает es на переменные BIOS
            mov     es,ax
            mov     al,[es:11h]     ;считывание старшего байта конфигурации
            mov     ah,al           ;копировать в другой регистр
            Curs    36,16           ;установка курсора
            test    al,10000b       ;проверка наличия порта джойстика
            jz      nojoy           ;0 - значит нет, переход
            Print   Pres            ;иначе - есть
            jmp     ports           ;переход на определение других портов
nojoy:      Print   NotP            ;вывод строки об отсутствии
ports:      shr     al,1            ;встать на число COM-портов
            and     al,111b         ;выделить биты этого числа
            add     al,30h          ;преобразовать число в ASCII
            mov     [SPmes+23],al   ;вставить количество COM-портов в строку
            mov     cl,6            ;сдвиг на 6 позиций вправо на число
            shr     ah,cl           ;LPT-портов
            add     ah,30h          ;преобразовать число в ASCII
            mov     [PPmes+23],ah   ;вставить количество LPT-портов в строку
            Curs    13,12           ;установить курсор
            Print   SPmes           ;вывести строку COM-портов
            Curs    13,14           ;установить курсор
            Print   PPmes           ;вывести строку LPT-портов
            xor     si,si           ;обнулить
            Curs    42,13           ;установить курсор
            mov     ch,2            ;сколько типов портов (COM-1, LPT-2)
cycport:    mov     cl,4            ;цикл на 4 порта
cycaddr:    mov     ax,[Word es:si] ;чтение адреса 1-го порта
            or      ax,ax           ;проверка на 0 - наличие порта
            jnz     addr            ;не 0 - порт есть
            lea     dx,[NotP]       ;иначе - его нет, адрес сообщения
            jmp     prs             ;печать сообщения
addr:       call    bin2hex         ;преобразовать адрес в 16-е число
            lea     dx,[HexBuf]     ;адрес буфера с числом
prs:        call    OutStr          ;вывод строки или числа
            add     si,2            ;продвинуться на следующий адрес
            dec     cl              ;уменьшить счетчик
            or      cl,cl           ;проверить его на 0
            jnz     cycaddr         ;если не 0 - продолжать цикл
            Curs    42,15           ;установка курсора
            dec     ch              ;уменьшение счетчика типа портов
            or      ch,ch           ;проверить его на 0
            jnz     cycport         ;если не 0 - следующий тип портов
            ret
ENDP        Ports_Def
;==============================================================================
PROC        DD_Def           ;процедура определения типов дисковых накопителей
            Curs   13,18            ;координаты курсора
            Print  FDm              ;вывод сообщения о FDD
            cmp    [PC_Type],0FCh   ;компьютер AT ?
            je     atDD             ;да - переход
            in     al,61h           ;иначе - получаем значение из порта B
            mov    bl,al            ;делаем копию
            cmp    [PC_Type],0FFh   ;компьютер PC ?
            je     pcDD             ;да - переход
            and    al,11110111b     ;обнуляем 3-й бит, один из режимов порта C
            out    61h,al           ;заменяем байт
            in     al,62h           ;получаем значение из порта C
            and    al,00001100b     ;выделяем биты числа дисководов
            shr    al,1             ;смещаем биты на начало байта
            shr    al,1
            inc    al               ;счет не с 0, а с 1
            add    al,30h           ;получаем число накопителей в ASCII
            mov    [Buf],al         ;помещаем число в буфер
            mov    [Buf+1],'$'      ;добавляем признак конца строки
            Print  Buf              ;печать содержимого буфера
            mov    al,bl            ;подготовка к восстановлению порта B
            out    61h,al           ;восстанавливаем байт
            jmp    exitDD           ;на выход
pcDD:       or     al,10000000b     ;устанавливаем бит 7 в 1
            out    61h,al           ;заменяем байт
            in     al,60h           ;получаем значение из порта A
            test   al,1             ;проверяем, есть ли дисководы
            jnz    existDD2         ;не 0 - значит есть
            Print  NotP             ;иначе вывод сообщения об отсутствии
            jmp    restpc           ;восстановить порт B
existDD2:   mov    cl,6             ;подготовка для сдвига AL
            shr    al,cl            ;сдвигаем 2 старших бита на 6 позиций
            inc    al               ;начинаем счет с 1, а не с 0
            add    al,30h           ;получаем число накопителей
            mov    [Buf],al         ;помещаем число в буфер
            mov    [Buf+1],'$'      ;добавляем признак конца строки
            Print  Buf              ;печать содержимого буфера
restpc:     mov    al,bl            ;подготовка к восстановлению порта B
            out    61h,al           ;восстанавливаем значение порта
            jmp    exitDD           ;на выход
atDD:       Print  FDa              ;вывод строки дисковода a:
            mov    al,10h           ;адрес ячейки CMOS с байтом описания FDD
            out    70h,al           ;вывод адреса - выборка ячейки
            jmp    $+2              ;задержка для срабатывания CMOS схем
            in     al,71h           ;чтение значения выбранной ячейки
            mov    ah,al            ;копия - в ah
            mov    cl,4             ;подготовка сдвига на 4 позиции
            shr    ah,cl            ;сдвиг полубайта дисковода A: в мл. часть
            and    al,15            ;выделение полубайта дисковода B:
            mov    cx,2             ;счетчик - 2 дисковода
            jmp    fdef             ;переход на декодирование
fddcyc:     Curs   36,19            ;установка курсора
            Print  FDb              ;и вывод строки для второго дисковода
            mov    ah,al            ;загрузка в ah информации о дисководе B:
fdef:       cmp    ah,1             ;тип - 360 Кб ?
            jne    not360           ;нет - проверка далее
            lea    dx,[f360]        ;иначе - загрузка адреса строки с типом
            jmp    fddout           ;переход на печать строки
not360:     cmp    ah,2             ;тип - 1.2 Мб ?
            jne    not12            ;нет - проверка далее
            lea    dx,[f12]         ;иначе - загрузка адреса строки с типом
            jmp    fddout           ;переход на печать строки
not12:      cmp    ah,3             ;тип - 720 Кб ?
            jne    not720           ;нет - проверка далее
            lea    dx,[f720]        ;иначе - загрузка адреса строки с типом
            jmp    fddout           ;переход на печать строки
not720:     cmp    ah,4             ;тип - 1.44 Мб ?
            jne    not144           ;нет - проверка далее
            lea    dx,[f144]        ;иначе - загрузка адреса строки с типом
            jmp    fddout           ;переход на печать строки
not144:     cmp    ah,5             ;тип - 2.88 Мб ?
            jne    nonefdd          ;нет - дисковод отсутствует
            lea    dx,[f288]        ;иначе - загрузка адреса строки с типом
            jmp    fddout           ;переход на печать строки
nonefdd:    lea    dx,[NotP]        ;загрузка адреса строки "отсутствует"
fddout:     call   OutStr           ;печать строки
            loop   fddcyc           ;цикл
            xor    ax,ax            ;обнулить рабочий регистр
            Curs   13,20            ;установка курсора
            Print  HDm1             ;вывод строки для жесткого диска 0
            mov    al,12h           ;адрес ячейки
            out    70h,al           ;CMOS-памяти с типом HDD
            jmp    $+2              ;задержка для срабатывания CMOS схем
            in     al,71h           ;чтение значения
            xor    bx,bx            ;обнулить рабочий регистр
            mov    bl,al            ;копия в bl
            mov    cl,4             ;подготовка сдвига на 4 позиции
            shr    al,cl            ;сдвиг полубайта диска 0: в младшую часть
            and    bl,15            ;выделение полубайта диска 1:
            mov    cx,2             ;счетчик на два диска
            jmp    hdef             ;переход на определение типа
hddcyc:     Curs   36,21            ;установка куссора
            Print  HDm2             ;вывод строки для диска 1:
            mov    al,bl            ;вернуть копию описания диска 1:
hdef:       or     al,al            ;диск присутствует ?
            jnz    hdexist          ;если да, то определяем тип
            lea    dx,[NotP]        ;иначе - сообщение "отсутствует"
            jmp    hdout            ;переход на печать
hdexist:    cmp    al,15            ;значение 15 означает тип >15
            je     adv1             ;если 15 - проверка дополнительных ячеек
            call   bin2dec          ;иначе - преобразование в 10-й формат
            jmp    hdnum            ;вывод номера
adv1:       cmp    cx,1             ;если определяем диск 0:
            ja     hdfst            ;то - переход (cx=2)
            mov    al,1Ah           ;иначе диск 1:, ячейка с типом диска 1:
            jmp    adv2             ;на чтение дополнительных ячеек
hdfst:      mov    al,19h           ;адрес ячейки с типом диска 0:
adv2:       out    70h,al           ;вывод адреса
            jmp    $+2              ;задержка
            in     al,71h           ;чтение значения
            call   bin2dec          ;преобразование в десятичное ASCII
hdnum:      lea    dx,[DecBuf]      ;адрес числа в буфере
hdout:      call   OutStr           ;вывод числа или сообщения
            loop   hddcyc           ;цикл
exitDD:     ret
ENDP        DD_Def
;==============================================================================
PROC        DOS_Def                     ;процедура определения версии DOS
            push   ax                   ;сохранение рабочего регистра
            mov    ax,3000h             ;функция определения версии DOS
            int    21h                  ;вызов функции
            add    al,30h               ;перевод основного номера в ASCII
            mov    [Byte Dmes+23],al    ;вставка номера в выводимую строку
            mov    al,ah                ;дополнительный номер в al
            xor    ah,ah                ;а ah - обнулить
            call   bin2dec              ;преобразование в ASCII
            mov    ah,[Byte DecBuf]     ;вставка дополнительного номера
            mov    [Byte Dmes+25],ah    ;в выводимую строку
            mov    ah,[Byte DecBuf+1]
            mov    [Byte Dmes+26],ah
            Curs   13,22                ;установка курсора
            Print  Dmes                 ;вывод строки для версии DOS
            pop    ax                   ;восстановление рабочего регистра
            ret                         ;возврат
ENDP        DOS_Def
;==============================================================================
;преобразует целое двоичное число в AX в строку десятичных ASCII-цифр в DecBuf
PROC        bin2dec
            push   bx cx dx di es       ;сохранение рабочих регистров
            push   ds                   ;загрузка es адресом сегмента данных
            pop    es
            lea    di,[DecBuf]          ;адрес буфера для формирования числа
            cld                         ;направление - "вперед"
            mov	   bx,10                ;делитель в BX
	    xor	   cx,cx                ;счетчик цифр в 0
divide:	    xor	   dx,dx                ;очистка остатка
            div    bx                   ;разделить преобразуемое число на 10
            add	   dl,'0'               ;добавить к остатку ASCII-код нуля
            push   dx                   ;записать полученную цифру в стек
            inc    cx                   ;увеличить счетчик цифр
            test   ax,ax                ;и, если еще есть, что делить,
            jnz    divide               ;продолжить деление на 10
store:      pop    ax                   ;считать цифру из стека
            stosb                       ;дописать ее в конец строки в ES:DI
            loop   store                ;продолжить для всех CX-цифр
            mov    al,'$'               ;признак конца строки
            stosb                       ;сохранить в буфере
            pop    es di dx cx bx       ;восстановление рабочих регистров
            ret
ENDP        bin2dec
;==============================================================================
PROC        bin2hex ;процедура преобразования двоичного числа в 16-е ASCII
            push   cx dx si di es       ;сохранение рабочих регистров
            push   ds                   ;загрузка es адресом сегмента данных
            pop    es
            lea    di,[HexBuf+3]        ;адрес буфера для HEX-числа
            std                         ;направление - "назад"
            mov    dx,ax                ;копия числа
            mov    cx,2                 ;для двух байт числа
            mov    ah,dl                ;младший байт
            jmp    hexlow               ;обработка
hexloop:    mov    ah,dh                ;старший байт
hexlow:     mov    al,ah                ;загрузка текущего байта
            and    al,15                ;выделение младшего полубайта
            stosb                       ;сохранение в буфере
            mov    al,ah                ;загрузка текущего байта
            shr    al,1                 ;смещение старшего полубайта
            shr    al,1
            shr    al,1
            shr    al,1
            stosb                       ;сохранение в буфере
            loop   hexloop              ;цикл для следующего байта
            inc    di                   ;встать на начало буфера
            mov    si,di                ;источник - начало буфера
            cld                         ;направление "вперед"
            mov    cx,4                 ;четыре HEX-цифры
ascii:      lodsb                       ;считать цифру
            cmp    al,9                 ;если больше 9
            ja     char                 ;то - это символ (A..F)
            add    al,'0'               ;иначе - преобразовать в ASCII
            jmp    next                 ;следующий
char:       add    al,'7'               ;проеобразовать в соотв. символ
next:       stosb                       ;сохранить обратно в буфер
            loop   ascii                ;цикл
            pop    es di si dx cx       ;восстановление рабочих регистров
            ret
ENDP        bin2hex
ENDS        _text
;==============================================================================
SEGMENT     _stack PARA STACK 'stack'   ;стековый сегмент
            DW     100h dup (?)         ;размер 256 байт
ENDS        _stack
;==============================================================================
            END    Start
